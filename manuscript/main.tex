%% Options:

%% twocolumn : Two column layout.
%% hf: enable header and footer.
\documentclass[twocolumn]{ceurart}

%%
%% One can fix some overfulls
\sloppy

%%
%% Minted listings support 
%% Need pygment <http://pygments.org/> <http://pypi.python.org/pypi/Pygments>
\usepackage{minted}
%% auto break lines
\setminted{breaklines=true}

\begin{document}

\copyrightyear{2023}
\copyrightclause{
    Copyright for this paper by its authors.
    Use permitted under Creative Commons License Attribution 4.0 
    International (CC BY 4.0).
}

\conference{
    ITAT'23: Information technologies -- Applications and Theory
    September 22--26, 2023, Tatranské Matliare, Vysoké Tatry
}

\title{Prefix-free graphs and suffix array construction in sublinear space}

\author[1]{Andrej Baláž}[
orcid=0000-0001-0002-0003,
email=andrejbalaz001@gmail.com,
]
\cormark[1]
\address[1]{
    Faculty of Mathematics, Physics and Informatics,
    Comenius University, Mlynská dolina F1, 842 48 Bratislava, Slovakia
}

% Footnotes
\cortext[1]{Corresponding author.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Recently, many graph structures for computational pangenomics were proposed.
  In order to be useful, these graph structures need to implement several
  operations such as efficient construction from many complete genomes,
  mapping of short and long read.
  These basic bioinformatics operations are well studied on sequential data,
  and together with data structures such as suffix trees, suffix arrays and 
  burrows wheeler transform allow high performance.
  Attempts to implement these operations on graphs brings with it many complications
  since these date structures are not easily obtainable for graphs.
  In this work, we introduce prefix-free graphs, a pangenomic data structure
  allowing to obtain the well known data structures from stringology in graph
  settings, which in turn allows for many efficient operations on pangenomes.
\end{abstract}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\begin{keywords}
  pangenome \sep
  suffix array
\end{keywords}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
Suffix array is a data structure used in many fields, such as stringology,
bioinformatics, and... .
Particularly in bioinformatics, it is used as part of FM index, which in turn
is used for read mapping.
Recently, a new paradigm in bioinformatics was formed, moving from a single
reference genome to a pangenome.
The term pangenome was first used by Tettelin et al. in 2005 during the
resequencing experiments on streptococcus.
Since then, the definition of a pangenome has shifted to any set of sequences
analysed jointly.
Nevertheless, most pangenomes consist of highly related sequences and thus are
highly repetitive.
This leads to representation of pangenomes as graphs, where similar genome
regions are represented by a single node and the nodes are conected to paths
representing the original sequences.
Several approaches of pangenomic graph construction exist, such as variation
graphs, cactus graphs, ...
Most of these approaches require an initial local alignment of similar regions,
which makes them computationally expensive.
Here we present a new class of graphs, prefix-free graphs, which are easy to
construct and provide a way how to efficiently index them to allow pattern 
search queries.
Pangenomes introduced by...
In computational pangenomics...
Repetitive datasets...
Graph pangenomes and textual pangenomes...
Prefix-free parsing is a technique...
Prefix-free graphs play an important role in improving space
complexity of several efficient algorithms, but are never the concept is never
framed as a pangenomic data structure.
We think that separating and clearly defining this data structure can lead to
more advancements...
Our contribution is in defining a data structure called prefix-free graphs and
showing how this data structure can be used to generate suffix array in
sublinear space.
Furthermore, we implemented two binarieš for an easy construction of prefix-free
graphs from a set of sequences, and from a graph in gfa format.
Furthermore, we implemented rust library for working with prefix-free graphs.
This library contains an iterator, which can be directly used to generate the 
suffix array in sublinear space.

\section{Prefix-free graphs}
% some intro?
The idea of prefix-free graphs is inspired by rsync \cite{}.
% what are prefix-free graphs
Given a set of sequences representing a pangenome, we can partition each
sequence into \emph{segment}s.
These segments form nodes of the prefix-free graph.
The edges of a graph represent the adjacencies of the segment pairs, which are 
present in the original strings.
The adjacent segments are overlapping by a fixed number of characters $k$.
We will call these $k$-sized overlaps triggers.
Another important feature of the segments is that they contain triggers only at
the start or at the end of a segment.
This feature guarantees that the set of segments is prefix-free, i.e. no
segment is a prefix of another segment.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/prefixfree_proof.png}
    \caption{Visual proof that the trigger words induce prefix-free segments.}
    \label{fig:proof}
\end{figure}

% how to construct prefix free graphs
To illustrate how to partition the sequences into segments consider a set of
strings $S = {TACTACGTACT, TCGTACTACT, TCGTCGTACTACT}$.
Next, assume we will partition the sequences using a set of trigger words 
$T = {AC, CG}$.

In stringology, strings are often flanked by so called \emph{sentinel} = $\$$.
In our case, we need to append $k$ sentinels to the sequences.
The reasons for doing so will become clear in the suffix array construction section.

Then, using a sliding window we can scan through the sequences and each time we
encounter a trigger word, we create a new segment from the start of the previous
trigger word to the end of the current trigger word.
Two special cases happen at the beginning of a sequence, when no previous
trigger was encountered, and at the end.
In the former case, the segment starts simply at the start of a sequence and in
the later case the segment ends at a sequence end.

During the sequence scan, each unique segment is assigned an ID.
The original sequence can then be represented as a list of IDs, also called 
\emph{path}s.

The result of this procedure is a set of segments and a list of paths.
In the previous example, the segments are ${ TAC, ACTAC, ACG, CGTAC, ACT\$\$, TCG, CGTCG }$
and the paths are $[  ]$.

Because each segment is represented in a set $S$ only once, the sum of lengths
of segments is usually much smaller than the length of original sequences.

This set of segments, together with the list of paths are already a prefix-free
graph, but in order to be useful for the next part, we need to normalize it.
By normalizing, we mean to sort the segments lexicographically and relabel the
paths accordingly.
This will give us a list of segments and a list of paths which can be directly
represented in the GFA format as shown in the Figure \ref{fig:gfa}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/pfg_gfa.png}
    \caption{Prefix-free graph in GFA format. Link lines omitted for brevity.}
    \label{fig:gfa}
\end{figure}

% add graph figure

The reconstruction of the original sequence can then be done by expanding 
the particular path, ignoring last $k$ characters of each segment.

\section{Suffix array construction}
Suffix array is a permutation of string positions which lexicographically
sorts the suffixes of the string starting at that position.
It is extremely powerful data structure with many applications in efficient
algorithms on strings.
Enhanced by additional data structures, such as for example longest common
prefix (LCP) array, it can fully substitute suffix tree and solve problems,
such as exact pattern matching, repeat finding, maximum exact matching (MEM)
finding, document retrieval and many more.

There exists several algorithms for suffix array construction in linear time
\cite{} with several practical implementations \cite{}.
Altough their time complexity is linear, these algorithms become bottlenecks in
some application due to their linear space complexity.
This is especially relevant in pangenomics, where the datasets often do not fit
in the memory.
Nonetheless, as we shown in previous sections, prefix-free graphs can represent
the pangenome in substantialy smaller space and therefore can fit in computer
memory.

Here we show another crucial advantage of prefix-free graphs - their ability to
output the suffix array of the original string iterativelly.
This allows us to generate the suffix array one-by-one with the possibility
to compress or use in subsequential computations directly, giving us the ability
to use the rich theory of suffix arrays without ever storing them.

\subsection{Iterator preparation}
In order to prepare the prefix-free graph to generate the suffix array of
original pangenome we need to create several data structures.
First, we concatenate all the prefix-free segments into a single string using
a separator $\#$ and append a sentinel $\$$.
We will call this concatenation \emph{segment join}.

Next, for the segment join we calculate the suffix array and the LCP array.
For this we can use the linear time, linear space algorithms mentioned previously,
since the segment join is assumed to be much smaller than the original pangenome.

Next, for each suffix of a segment join, we need to calculate the corresponding
segment ID and the segment position.
These two arrays represent the current suffix of a segment join starts with a
particular segment and the position in this segment.
This can be computed using an inverse permutation of a suffix array of a segment
join in linear time.
To illustrate the procedure, consider the segment join of our running example in
Figure \ref{fig:ids_and_positions}.
Each position of the join can be assigned a segment ID and a position in current
segment by linearly iterating the segment join and incrementing ID and position
accordingly.
Then, applying the inverse permutation of a suffix array to these arrays will
change the order of computed values in a way corresponding to the sorted suffixes.
The Table \ref{tab:suffix} shows the resulting suffix array, LCP array, segment ID array and segment position array.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/ids_and_positions.png}
    \caption{
        Segment IDs and segment positions of a segment join. Permuting these
        according to the inverse permutation of a suffix array results in 
        segment ID array and segment position array shown in the Table \ref{fig:segment_sa}.
    }
    \label{fig:ids_and_positions}
\end{figure}

\input{sa_table.tex}

In the Table \ref{tab:suffix}, one row can represent multiple positions of the
pangenome.
In order to be able to reconstruct the suffix array, we need to store some
additional information for each segment.
For each segment, we store it's length, it's starting positions in the implicit
concatenated pangenome and the rank of it's right context.

\input{segment_table.tex}

\section{Related work}
There are several proposed data structures implicitly relying on the structure
of prefix-free graphs.

Rpair: rescaling repair with rsync \cite{2019gagie}
Prefix-free parsing for building big BWTs \cite{2019boucher}
MONI and r-index \cite{}
Prefix-free Wheeler graphs \cite{2022pfwg}
MARIA \cite{2022maria}

All of these works implement their own version of prefix-free graphs.
We argue that separating prefix-free graphs as a standalone data structure can
bring several benefits:

\begin{itemize}
    \item reduce the complexity of the presentation
    \item allowing for better optimization of algorithms related to prefix-free graphs
    \item supporting the theoretical research by clearly deliminating the relevant terms
    \item allowing to bring prefix-free graphs closer to the biological data
\end{itemize}

Related to the last point, we remark that a possible future research can be in
the proper choice of trigger words.
As an example, we used stop codons in our experiments.
This could create prefix-free graphs capturing some biologically relevant phenomena.
Other options are recombination hotspots, highly repetitive elements, different
binding sites and sites with increased breakage.

\section{Results}
We implemented the prefix-free graphs package in rust programming language.
There are two binary crates and one library crate included in the package.
Binary crates serve the purpose of creating prefix-free graphs from FASTA and from GFA formats.
Library crate provides an interface for working with the prefix-free graphs,
mainly an iterator of suffix array in sublinear space and linear time.

The binary crates are fasta2pfg and gfa2pfg with usage:
\begin{minted}{bash}
fasta2pfg -t triggers.txt < pangenome.fna > pfg.gfa

gfa2pfg -t triggers.txt < pangenome.gfa > pfg.gfa
\end{minted}

The library can be used from within rust programming language as follows:

\begin{minted}{rust}
let pfg = PFG::load("pfg.gfa");

for (i, sa_i) in pfg.iter().enumerate() {
    println!("{}\t{}", i, sa_i);
}
\end{minted}

\section{Discussion}

\begin{acknowledgments}
    Thanks to Alessia and Askar for their encouragement while developing prefix-free graphs.
\end{acknowledgments}

\bibliography{sources}

\appendix

\section{Online Resources}

The sources for the prefix-free graphs are available via
\begin{itemize}
\item \href{https://github.com/andynet/pfg}{GitHub}.
\end{itemize}

\end{document}

